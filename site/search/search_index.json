{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation Here, you will learn about how to use all of what thenewboston gem has to offer. If you notice an error or typo, then please create a pull request yourself and we can pull in the changes to save everyone some time. Getting Started There are two ways to use the library. You can place gem \"thenewboston\" in your application's Gemfile and run bundle install Or install it yourself by running gem install thenewboston For simplicity, we will not be including require statements in our examples but you can use the library(gem) by using require \"thenewboston\" at the top of your code. Table of Contents Account Creating Accounts Getting Account Numbers and Signing Keys Verifying key pair Creating Signatures Using Signed Data and Signed Messages","title":"Documentation"},{"location":"#documentation","text":"Here, you will learn about how to use all of what thenewboston gem has to offer. If you notice an error or typo, then please create a pull request yourself and we can pull in the changes to save everyone some time.","title":"Documentation"},{"location":"#getting-started","text":"There are two ways to use the library. You can place gem \"thenewboston\" in your application's Gemfile and run bundle install Or install it yourself by running gem install thenewboston For simplicity, we will not be including require statements in our examples but you can use the library(gem) by using require \"thenewboston\" at the top of your code.","title":"Getting Started"},{"location":"#table-of-contents","text":"Account Creating Accounts Getting Account Numbers and Signing Keys Verifying key pair Creating Signatures Using Signed Data and Signed Messages","title":"Table of Contents"},{"location":"account/","text":"Account In this section, we will discuss how to create accounts and use them within other parts of your code with ease. Creating Accounts Creating local accounts with thenewboston gem is extremely simple. All you have to do is access the Account class under the Thenewboston module from the library. These accounts are also used when updating thenewboston server nodes (banks + validators) with requests. Here is a simple example of us using the Account class: # Generates a random account with a random hex signing key string. account = Thenewboston::Account.new account.account_number_hex # random account number hex string account.signing_key_hex # random account signing key hex string As you can tell, if you don't pass in anything into the Account class, then it just generates a random account for you. Now, let's get a little more complex, you can pass in the signing_key as the first parameter within Account and it will set the signing_key_hex of the Account as it. Also, since we are using the signing-based cryptographic algorithms, the account_number_hex can be generated automatically. Here is an example of this behavior in action: signing_key = \"15fbd07fc5e5764bf5919ad41151066f0708e9e2dc11dd42dd1dd671e9485b20\" account = Thenewboston::Account.new(signing_key) account.account_number_hex # the corresponding account number hex account.signing_key_hex # the account signing key Remember: You must keep your account signing key secret at all times. If someone obtains your signing key, then your account is compromised along with all of its funds. Alright, so we have checked out all of the other ways of instantiating an Account with this library. Getting Account Numbers and Signing Keys Obviously, this was used in the earlier examples when we were getting the account number and signing key as a hex string. Here is an example of us getting the account_number_hex and signing_key_hex of a random Account : account = Thenewboston::Account.new account.account_number_hex # the account number hex string account.signing_key_hex # the account signing key hex string Creating Signatures In this section, we will learn how to create signatures for a given Account using the create_signature method for a message . If you don't understand what these signatures and private/public keys really are, then check out this article by Prevail on the topic . The create_signature method just takes in one parameter: a string that is the message to generate a signature for. Here is an example of us signing \"Hello world\" : account = Thenewboston::Account.new signature = account.create_signature(\"Hello World\") # the generated signature generated using the account's `signingKey` and `message` From running that code, you can see that the create_signature method returned a 128 character long hex string signature. If you re-run that code multiple times, you will then notice that the generated signature is different. That is because the signature depends on two variables: the account signing key and the message. The account signing key also is changing on every run because we are generating a random Account to use, thus resulting in different outcomes. Verifying Signatures If you need to verify a signature for a message, then you can easily use the Account.valid_signature? static method. The method takes in the message first, the signature (signed message) second and then the account number last. Here is example of how one might use this method: account = Thenewboston::Account.new message = { greeting: \"Hello World\" } signature = account.create_signature(message) Thenewboston::Account.valid_signature?(message, signature, account.account_number_hex) # returns true only if the account number was used to sign the message and the signed message matches the signature Verifying Account Keys If you need to verify that the given signing key and account number are paired together, then you can easily use the Account.isValidPair static method. The method takes in the signing key first and the account number second. Here is example of how one might use this method: Thenewboston::Account.valid_keypair?(\"SIGNING_KEY\", \"ACCOUNT_NUMBER\"); # returns true only if the signing key's public key is the given account number Using Signed Data and Signed Messages We have already talked about creating signatures, so let's learn how we can apply them to creating signed messages. Here is an example of us creating a signed message: Note that all of the signature and node_identifier properties that we are generating are almost random as we are not passing any arguments into the Account class. account = Thenewboston::Account.new signed_message = account.create_signed_message({ name: \"Tuna\" }) # { # :data=> { :name=> \"Tuna\" }, # :node_identifier=> \"4c8eef36b3d1466a61806c2a76480c64e5b5a0a7e0b84076d86d029b4e448c05\", # :signature=> \"61e16531f8ed0db1900c81d2d6591770fc1f10e762eb86e0f4e57ac5c5637e7d5bdc168d2eee36ef26093dc4f8e9205291fb124869fb28d0e6f643d558e9f107\" # } If you were to log out account 's account_number_hex , then you would realize that the node_identifier is just that account. The reason for that is because only servers have the account signing key to be able to authenticate their requests. Alright, so that's the Account class in a nutshell! If you have any things you would like to add please send a pull request or an issue so we can fix it!","title":"Account"},{"location":"account/#account","text":"In this section, we will discuss how to create accounts and use them within other parts of your code with ease.","title":"Account"},{"location":"account/#creating-accounts","text":"Creating local accounts with thenewboston gem is extremely simple. All you have to do is access the Account class under the Thenewboston module from the library. These accounts are also used when updating thenewboston server nodes (banks + validators) with requests. Here is a simple example of us using the Account class: # Generates a random account with a random hex signing key string. account = Thenewboston::Account.new account.account_number_hex # random account number hex string account.signing_key_hex # random account signing key hex string As you can tell, if you don't pass in anything into the Account class, then it just generates a random account for you. Now, let's get a little more complex, you can pass in the signing_key as the first parameter within Account and it will set the signing_key_hex of the Account as it. Also, since we are using the signing-based cryptographic algorithms, the account_number_hex can be generated automatically. Here is an example of this behavior in action: signing_key = \"15fbd07fc5e5764bf5919ad41151066f0708e9e2dc11dd42dd1dd671e9485b20\" account = Thenewboston::Account.new(signing_key) account.account_number_hex # the corresponding account number hex account.signing_key_hex # the account signing key Remember: You must keep your account signing key secret at all times. If someone obtains your signing key, then your account is compromised along with all of its funds. Alright, so we have checked out all of the other ways of instantiating an Account with this library.","title":"Creating Accounts"},{"location":"account/#getting-account-numbers-and-signing-keys","text":"Obviously, this was used in the earlier examples when we were getting the account number and signing key as a hex string. Here is an example of us getting the account_number_hex and signing_key_hex of a random Account : account = Thenewboston::Account.new account.account_number_hex # the account number hex string account.signing_key_hex # the account signing key hex string","title":"Getting Account Numbers and Signing Keys"},{"location":"account/#creating-signatures","text":"In this section, we will learn how to create signatures for a given Account using the create_signature method for a message . If you don't understand what these signatures and private/public keys really are, then check out this article by Prevail on the topic . The create_signature method just takes in one parameter: a string that is the message to generate a signature for. Here is an example of us signing \"Hello world\" : account = Thenewboston::Account.new signature = account.create_signature(\"Hello World\") # the generated signature generated using the account's `signingKey` and `message` From running that code, you can see that the create_signature method returned a 128 character long hex string signature. If you re-run that code multiple times, you will then notice that the generated signature is different. That is because the signature depends on two variables: the account signing key and the message. The account signing key also is changing on every run because we are generating a random Account to use, thus resulting in different outcomes.","title":"Creating Signatures"},{"location":"account/#verifying-signatures","text":"If you need to verify a signature for a message, then you can easily use the Account.valid_signature? static method. The method takes in the message first, the signature (signed message) second and then the account number last. Here is example of how one might use this method: account = Thenewboston::Account.new message = { greeting: \"Hello World\" } signature = account.create_signature(message) Thenewboston::Account.valid_signature?(message, signature, account.account_number_hex) # returns true only if the account number was used to sign the message and the signed message matches the signature","title":"Verifying Signatures"},{"location":"account/#verifying-account-keys","text":"If you need to verify that the given signing key and account number are paired together, then you can easily use the Account.isValidPair static method. The method takes in the signing key first and the account number second. Here is example of how one might use this method: Thenewboston::Account.valid_keypair?(\"SIGNING_KEY\", \"ACCOUNT_NUMBER\"); # returns true only if the signing key's public key is the given account number","title":"Verifying Account Keys"},{"location":"account/#using-signed-data-and-signed-messages","text":"We have already talked about creating signatures, so let's learn how we can apply them to creating signed messages. Here is an example of us creating a signed message: Note that all of the signature and node_identifier properties that we are generating are almost random as we are not passing any arguments into the Account class. account = Thenewboston::Account.new signed_message = account.create_signed_message({ name: \"Tuna\" }) # { # :data=> { :name=> \"Tuna\" }, # :node_identifier=> \"4c8eef36b3d1466a61806c2a76480c64e5b5a0a7e0b84076d86d029b4e448c05\", # :signature=> \"61e16531f8ed0db1900c81d2d6591770fc1f10e762eb86e0f4e57ac5c5637e7d5bdc168d2eee36ef26093dc4f8e9205291fb124869fb28d0e6f643d558e9f107\" # } If you were to log out account 's account_number_hex , then you would realize that the node_identifier is just that account. The reason for that is because only servers have the account signing key to be able to authenticate their requests. Alright, so that's the Account class in a nutshell! If you have any things you would like to add please send a pull request or an issue so we can fix it!","title":"Using Signed Data and Signed Messages"},{"location":"bank/","text":"Bank In this section, we will discuss how to interact with thenewboston banks using your code. Creating Banks Creating a Bank object will allow you to interact with thenewboston bank through code. It takes the URL of the bank as a parameter. # Instantiates a new bank bank = Thenewboston::Bank.new(\"http://54.183.16.194\") You can get the URL passed as a parameter once the object is created - bank.url # http://54.183.16.194 It also takes a second optional parameter to specify the pagination options. In case it is not passed, there are default values set - bank.options # {:defaultPagination=>{:limit=>20, :offset=>0}} You can set your pagination options while creating the bank object as follows - bank = Thenewboston::Bank.new(\"http://54.183.16.194\", {defaultPagination: {limit: 10, offset: 10}}) bank.options # {:defaultPagination=>{:limit=>10, :offset=>10}} The defaultPagination object is used as default options, when API calls are made to the bank. Get Config The bank configuration can be retrieved as follows - config = bank.get_config # {\"primary_validator\"=>{\"account_number\"=>\"cafd36d7fc4eb7a7a2b2d242432b4af05a70a7fa54ba5bafcaf0a79a44aa9e43\", \"ip_address\"=>\"52.52.160.149\", \"node_identifier\"=>\"245c38bd9cfcff1337e6350826a3016e7b5a76ebc593e6ad89d27f2bda868ebf\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"root_account_file\"=>\"http://52.52.160.149:80/media/root_account_file.json\", \"root_account_file_hash\"=>\"c7946c8ab7f978c925b91269e260f64fba080e867150fcc73c6310c2f66ca6ef\", \"seed_block_identifier\"=>\"\", \"daily_confirmation_rate\"=>1, \"trust\"=>\"100.00\"}, \"account_number\"=>\"982dcfc62db8f1733141c8f5c29e25c8b4489dbf237053d1589d9a3909037187\", \"ip_address\"=>\"54.183.16.194\", \"node_identifier\"=>\"88d57e07642fa7e4ee23906aa1bc0db779ee0d4fa442361fd27ec663d4b69ace\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"node_type\"=>\"BANK\"} The function get_config does not take any parameters. The config includes data like selected primary validator, IP address, port, node identifier and so on. Get accounts We can get the accounts which are linked to the bank with the get_accounts method - accounts = bank.get_accounts # {\"count\"=>382, \"next\"=>\"http://54.183.16.194/accounts?limit=20&offset=20\", \"previous\"=>nil, \"results\"=>[{\"id\"=>\"4e4380f8-2dff-4a84-96c2-4b331f8a7be8\", \"created_date\"=>\"2021-07-01T04:30:08.212090Z\", \"modified_date\"=>\"2021-07-01T04:30:08.212111Z\", \"account_number\"=>\"a37e2836805975f334108b55523634c995bd2a4db610062f404510617e83126f\", \"trust\"=>\"0.00\"}, ...]} Update account trust The trust for a particular account can be updated as follows signing_key = \"15fbd07fc5e5764bf5919ad41151066f0708e9e2dc11dd42dd1dd671e9485b20\" account = Thenewboston::Account.new(signing_key) trust = 50 account_details = bank.update_account_trust(account.account_number_hex, trust, account) # {\"id\"=>\"4e4380f8-2dff-4a84-96c2-4b331f8a7be8\", \"created_date\"=>\"2021-07-01T04:30:08.212090Z\", \"modified_date\"=>\"2021-07-01T04:30:08.212111Z\", \"account_number\"=>\"a37e2836805975f334108b55523634c995bd2a4db610062f404510617e83126f\", \"trust\"=>\"50.00\"} Get Transactions We can get all the bank transactions using the get_transactions method - transactions = bank.get_transactions # {\"count\"=>16652, \"next\"=>\"http://54.183.16.194/bank_transactions?limit=20&offset=20\", \"previous\"=>nil, \"results\"=>[{\"id\"=>\"65541a71-19b2-464d-aea2-71c9a0602e08\", \"block\"=>{\"id\"=>\"cf4dc112-61c8-45fd-9aaa-76abe9b9dac4\", \"created_date\"=>\"2022-01-22T16:58:40.497600Z\", \"modified_date\"=>\"2022-01-22T16:58:40.497629Z\", \"balance_key\"=>\"b8b900adbd408bb225803bf581d830c9c538088276c7d5358ca79aa53969324f\", \"sender\"=>\"0913b206c1baf493a9c490d8bae279202977b387184c1bd630d0626e9846867b\", \"signature\"=>\"79bb2fdb48d95bc32d46ff4e5d42dd083ece5971d60fce59191feda8afa304f8a630e110fd7acad23f823083c504b8c8033c9a961d8078cecdb7afee020f720d\"}, \"amount\"=>1, \"fee\"=>\"BANK\", \"memo\"=>\"\", \"recipient\"=>\"982dcfc62db8f1733141c8f5c29e25c8b4489dbf237053d1589d9a3909037187\"}, {\"id\"=>\"69650fc9-463e-4cd3-9ece-f66f9a9ad0fa\", \"block\"=>{\"id\"=>\"cf4dc112-61c8-45fd-9aaa-76abe9b9dac4\", \"created_date\"=>\"2022-01-22T16:58:40.497600Z\", \"modified_date\"=>\"2022-01-22T16:58:40.497629Z\", \"balance_key\"=>\"b8b900adbd408bb225803bf581d830c9c538088276c7d5358ca79aa53969324f\", \"sender\"=>\"0913b206c1baf493a9c490d8bae279202977b387184c1bd630d0626e9846867b\", \"signature\"=>\"79bb2fdb48d95bc32d46ff4e5d42dd083ece5971d60fce59191feda8afa304f8a630e110fd7acad23f823083c504b8c8033c9a961d8078cecdb7afee020f720d\"}, \"amount\"=>1, \"fee\"=>\"\", \"memo\"=>\"tnb_gifts_437f11061dc9433e9169e66f8afcf18c\", \"recipient\"=>\"c4caa42b2a01b31ee187468ac63bd64745f67ec3b20191a54eb55ba20d5adbb0\"}, ...]} Get Banks We can use get_banks method to get all connected banks banks = bank.get_banks # {\"count\"=>4, \"next\"=>nil, \"previous\"=>nil, \"results\"=>[{\"account_number\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"ip_address\"=>\"13.233.77.254\", \"node_identifier\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"}, {\"account_number\"=>\"855edee3204f0bbc6b14b2d61d56fd06636d6d6400fd3ff97644c11d9588d1e2\", \"ip_address\"=>\"45.33.60.42\", \"node_identifier\"=>\"8534f05f7eac8cb0cbf4d591c51484fc20c6ee9c522b5213e4572e68d97991be\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"}, {\"account_number\"=>\"982dcfc62db8f1733141c8f5c29e25c8b4489dbf237053d1589d9a3909037187\", \"ip_address\"=>\"54.183.16.194\", \"node_identifier\"=>\"88d57e07642fa7e4ee23906aa1bc0db779ee0d4fa442361fd27ec663d4b69ace\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"100.00\"}, {\"account_number\"=>\"6ec99cf6656845c526fda71f1b437fe7de965e3c425b96c44b27c12a58872e93\", \"ip_address\"=>\"52.2.117.242\", \"node_identifier\"=>\"14607d3ee4f50d72ac4204eac9b52e9c8db8dda67347c7eba6e6ea3e8b0de7d9\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"}]} Get individual bank We can also get details about a particular bank using the get_bank method and passing the bank's node_identifier bank_details = bank.get_bank(\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\") # {\"account_number\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"ip_address\"=>\"13.233.77.254\", \"node_identifier\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"} Update bank trust We can also update the trust of a specific bank by using the update_bank_trust method signing_key = \"15fbd07fc5e5764bf5919ad41151066f0708e9e2dc11dd42dd1dd671e9485b20\" network_id_key_pair = Thenewboston::Account.new(signing_key) trust = 50 bank_to_update = \"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\" bank.update_bank_trust(bank_to_update, trust, network_id_key_pair) # {\"account_number\"=>\"46c5b1e48822bfc9ce8ecd21b90af2ba70e19088f37d3e40738dfdb71871e8b7\", \"ip_address\"=>\"54.183.16.194\", \"node_identifier\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"50.00\"}","title":"Bank"},{"location":"bank/#bank","text":"In this section, we will discuss how to interact with thenewboston banks using your code.","title":"Bank"},{"location":"bank/#creating-banks","text":"Creating a Bank object will allow you to interact with thenewboston bank through code. It takes the URL of the bank as a parameter. # Instantiates a new bank bank = Thenewboston::Bank.new(\"http://54.183.16.194\") You can get the URL passed as a parameter once the object is created - bank.url # http://54.183.16.194 It also takes a second optional parameter to specify the pagination options. In case it is not passed, there are default values set - bank.options # {:defaultPagination=>{:limit=>20, :offset=>0}} You can set your pagination options while creating the bank object as follows - bank = Thenewboston::Bank.new(\"http://54.183.16.194\", {defaultPagination: {limit: 10, offset: 10}}) bank.options # {:defaultPagination=>{:limit=>10, :offset=>10}} The defaultPagination object is used as default options, when API calls are made to the bank.","title":"Creating Banks"},{"location":"bank/#get-config","text":"The bank configuration can be retrieved as follows - config = bank.get_config # {\"primary_validator\"=>{\"account_number\"=>\"cafd36d7fc4eb7a7a2b2d242432b4af05a70a7fa54ba5bafcaf0a79a44aa9e43\", \"ip_address\"=>\"52.52.160.149\", \"node_identifier\"=>\"245c38bd9cfcff1337e6350826a3016e7b5a76ebc593e6ad89d27f2bda868ebf\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"root_account_file\"=>\"http://52.52.160.149:80/media/root_account_file.json\", \"root_account_file_hash\"=>\"c7946c8ab7f978c925b91269e260f64fba080e867150fcc73c6310c2f66ca6ef\", \"seed_block_identifier\"=>\"\", \"daily_confirmation_rate\"=>1, \"trust\"=>\"100.00\"}, \"account_number\"=>\"982dcfc62db8f1733141c8f5c29e25c8b4489dbf237053d1589d9a3909037187\", \"ip_address\"=>\"54.183.16.194\", \"node_identifier\"=>\"88d57e07642fa7e4ee23906aa1bc0db779ee0d4fa442361fd27ec663d4b69ace\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"node_type\"=>\"BANK\"} The function get_config does not take any parameters. The config includes data like selected primary validator, IP address, port, node identifier and so on.","title":"Get Config"},{"location":"bank/#get-accounts","text":"We can get the accounts which are linked to the bank with the get_accounts method - accounts = bank.get_accounts # {\"count\"=>382, \"next\"=>\"http://54.183.16.194/accounts?limit=20&offset=20\", \"previous\"=>nil, \"results\"=>[{\"id\"=>\"4e4380f8-2dff-4a84-96c2-4b331f8a7be8\", \"created_date\"=>\"2021-07-01T04:30:08.212090Z\", \"modified_date\"=>\"2021-07-01T04:30:08.212111Z\", \"account_number\"=>\"a37e2836805975f334108b55523634c995bd2a4db610062f404510617e83126f\", \"trust\"=>\"0.00\"}, ...]}","title":"Get accounts"},{"location":"bank/#update-account-trust","text":"The trust for a particular account can be updated as follows signing_key = \"15fbd07fc5e5764bf5919ad41151066f0708e9e2dc11dd42dd1dd671e9485b20\" account = Thenewboston::Account.new(signing_key) trust = 50 account_details = bank.update_account_trust(account.account_number_hex, trust, account) # {\"id\"=>\"4e4380f8-2dff-4a84-96c2-4b331f8a7be8\", \"created_date\"=>\"2021-07-01T04:30:08.212090Z\", \"modified_date\"=>\"2021-07-01T04:30:08.212111Z\", \"account_number\"=>\"a37e2836805975f334108b55523634c995bd2a4db610062f404510617e83126f\", \"trust\"=>\"50.00\"}","title":"Update account trust"},{"location":"bank/#get-transactions","text":"We can get all the bank transactions using the get_transactions method - transactions = bank.get_transactions # {\"count\"=>16652, \"next\"=>\"http://54.183.16.194/bank_transactions?limit=20&offset=20\", \"previous\"=>nil, \"results\"=>[{\"id\"=>\"65541a71-19b2-464d-aea2-71c9a0602e08\", \"block\"=>{\"id\"=>\"cf4dc112-61c8-45fd-9aaa-76abe9b9dac4\", \"created_date\"=>\"2022-01-22T16:58:40.497600Z\", \"modified_date\"=>\"2022-01-22T16:58:40.497629Z\", \"balance_key\"=>\"b8b900adbd408bb225803bf581d830c9c538088276c7d5358ca79aa53969324f\", \"sender\"=>\"0913b206c1baf493a9c490d8bae279202977b387184c1bd630d0626e9846867b\", \"signature\"=>\"79bb2fdb48d95bc32d46ff4e5d42dd083ece5971d60fce59191feda8afa304f8a630e110fd7acad23f823083c504b8c8033c9a961d8078cecdb7afee020f720d\"}, \"amount\"=>1, \"fee\"=>\"BANK\", \"memo\"=>\"\", \"recipient\"=>\"982dcfc62db8f1733141c8f5c29e25c8b4489dbf237053d1589d9a3909037187\"}, {\"id\"=>\"69650fc9-463e-4cd3-9ece-f66f9a9ad0fa\", \"block\"=>{\"id\"=>\"cf4dc112-61c8-45fd-9aaa-76abe9b9dac4\", \"created_date\"=>\"2022-01-22T16:58:40.497600Z\", \"modified_date\"=>\"2022-01-22T16:58:40.497629Z\", \"balance_key\"=>\"b8b900adbd408bb225803bf581d830c9c538088276c7d5358ca79aa53969324f\", \"sender\"=>\"0913b206c1baf493a9c490d8bae279202977b387184c1bd630d0626e9846867b\", \"signature\"=>\"79bb2fdb48d95bc32d46ff4e5d42dd083ece5971d60fce59191feda8afa304f8a630e110fd7acad23f823083c504b8c8033c9a961d8078cecdb7afee020f720d\"}, \"amount\"=>1, \"fee\"=>\"\", \"memo\"=>\"tnb_gifts_437f11061dc9433e9169e66f8afcf18c\", \"recipient\"=>\"c4caa42b2a01b31ee187468ac63bd64745f67ec3b20191a54eb55ba20d5adbb0\"}, ...]}","title":"Get Transactions"},{"location":"bank/#get-banks","text":"We can use get_banks method to get all connected banks banks = bank.get_banks # {\"count\"=>4, \"next\"=>nil, \"previous\"=>nil, \"results\"=>[{\"account_number\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"ip_address\"=>\"13.233.77.254\", \"node_identifier\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"}, {\"account_number\"=>\"855edee3204f0bbc6b14b2d61d56fd06636d6d6400fd3ff97644c11d9588d1e2\", \"ip_address\"=>\"45.33.60.42\", \"node_identifier\"=>\"8534f05f7eac8cb0cbf4d591c51484fc20c6ee9c522b5213e4572e68d97991be\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"}, {\"account_number\"=>\"982dcfc62db8f1733141c8f5c29e25c8b4489dbf237053d1589d9a3909037187\", \"ip_address\"=>\"54.183.16.194\", \"node_identifier\"=>\"88d57e07642fa7e4ee23906aa1bc0db779ee0d4fa442361fd27ec663d4b69ace\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"100.00\"}, {\"account_number\"=>\"6ec99cf6656845c526fda71f1b437fe7de965e3c425b96c44b27c12a58872e93\", \"ip_address\"=>\"52.2.117.242\", \"node_identifier\"=>\"14607d3ee4f50d72ac4204eac9b52e9c8db8dda67347c7eba6e6ea3e8b0de7d9\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"}]}","title":"Get Banks"},{"location":"bank/#get-individual-bank","text":"We can also get details about a particular bank using the get_bank method and passing the bank's node_identifier bank_details = bank.get_bank(\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\") # {\"account_number\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"ip_address\"=>\"13.233.77.254\", \"node_identifier\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"0.00\"}","title":"Get individual bank"},{"location":"bank/#update-bank-trust","text":"We can also update the trust of a specific bank by using the update_bank_trust method signing_key = \"15fbd07fc5e5764bf5919ad41151066f0708e9e2dc11dd42dd1dd671e9485b20\" network_id_key_pair = Thenewboston::Account.new(signing_key) trust = 50 bank_to_update = \"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\" bank.update_bank_trust(bank_to_update, trust, network_id_key_pair) # {\"account_number\"=>\"46c5b1e48822bfc9ce8ecd21b90af2ba70e19088f37d3e40738dfdb71871e8b7\", \"ip_address\"=>\"54.183.16.194\", \"node_identifier\"=>\"ddf057f339fbd165c268bf84956ce186eb4209c8b5e81900509cbbc70b6876c5\", \"port\"=>80, \"protocol\"=>\"http\", \"version\"=>\"v1.0\", \"default_transaction_fee\"=>1, \"trust\"=>\"50.00\"}","title":"Update bank trust"}]}